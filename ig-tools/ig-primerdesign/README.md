# Primer Design

Цели
----
Есть гуманизированный сиквенс:
`
QLQLQESGGGLVQPGGSLRLSCAASGFTFT RYAMS WVRQAPGKGLEWVS AINSGGGSTYYADSVKG RFTISRDNAKNTVYLQLNSLKTEDMADVLVCRG GGTLGGR
EV  V                        S                                                S   L   M   RA  T   YY
`

Требуется подобрать минимальный набор праймеров, способный при синтезе дать все возможные варианты замен. При этом к праймерам предъявляются следующие условия:
* Проверка на hairpin
* GC контент - должен быть равномерным
* Уникальность праймеров и липких концов - праймеры должны соединяться только с ожидаемыми праймерами, исключая рандомные соединения липких концов

### Простейшая реализация
* Пример лежит в PrintUtilsTest
* `proteinToCodonSets()` - Конвертируем String аминокислот в type Sequence = List[Set[String]], где Set[String] - это множество триплетов для аминокислоты в i-й позиции
* `flatten()` - делаем из нуклеотидный Sequence, но в 3 раза длиннее. При проходе мы заменем Set[String] с триплетами на 3 Set[String] с множеством нуклеотидов в i-й позиции триплета. Например: `Set("UUU", "UUC", "UUA", "UUG") => List(Set("U"), Set("U"), Set("U", "A", "C", "G"))`
* На выходе получился граф, в котором i и i + 1 элементы списка (а элемент списка - это множество нуклеотидов) должны быть соединены ребрами. Соединяются все i-е нуклеотиды со всеми j-ми. Это не совсем корректно. Например. Leucine - у него 6 триплетов, но из графа вида List(Set("C", "T"), Set("T"), Set("A", "C", "G", "T")) можно получить 8 триплетов, а должно быть только 6
* `equals()` - сравнивает 2 Sequence. Равенство будет в случае если в каждой позиции списка находится Set с одним нуклеотидом, одинаковым для обоих списков в данной позиции. Мы не можем получить из двух таких списков разные сиквенсы. Но это становится возможным, если хотя бы в одной позиции одного списка есть выбор хотя бы из двух нуклеотидов
* `findOverlaps()` - разделяет Sequence на перекрывающиеся группы, проверяя уникальность перекрытий с помощью equals()

### Вывод
см. PrintUtilsTest
Под каждой сплошной строкой праймера в колонках под некоторыми позициями предложены синонимичные замены. Нужно быть аккуратным с лицином, ибо для него не все замены корректны.

### Реализация в виде графа
* Поддерживается неявное преобразование строки в Sequence (это List[Set[String]]). Sequence поддерживает добавление альтернативных аминокислот/нуклеотидов в i-й позиции исходной последовательности
* Triquence - Trie + Sequence - представление Sequence в виде направленного графа с поправками на случаи с Leucine (см. вышк - 6 возможных путей вместо 8). Trie - потому что 1 и 2 позиции в кодоне действительно образуют префиксное дерево
* Пример лежит в TriquenceTest ("should build a Triequence") - на печать выводится граф в .dot формате, который можно открыть GraphViz. Квадратной рамкой выделяется аминокислота (вверху рамки есть ее название)
* Пример генератора праймеров с рандомным выбором находится в PrintUtilsTest("should supports new splitWithEqualGC() primers splitter"). Параметр pieces - это число праймеров, которые мы хотим получить. bodySize - это минимальная длина праймера без учета липких концов (т.е. "уникальная" часть). overlap - длина липких концов. Границы праймеров выбираются рандомно (метод genRandomBorders()) (но так, чтобы длина праймеров была не меньше bodySize, а их число было равно pieces), а затем выбирается наилучшее разбиение, которое минимизирует дисперсию gc контента в каждом праймере.